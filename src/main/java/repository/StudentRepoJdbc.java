package repository;


import constants.Departments;
import constants.Status;
import model.Student;
import utility.DatabaseConnector;

import java.sql.*;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * JDBC implementation of {@link StudentRepo} that communicates with a MySQL database.
 * <p>
 * This class handles CRUD operations for Student entities and maps them to the 'students' table.
 * It uses JDBC prepared statements to safely execute parameterized SQL queries.
 * <p>
 * Errors during SQL operations are logged and appropriate results are returned.
 */
public class StudentRepoJdbc implements StudentRepo {

    private static final Logger LOGGER = Logger.getLogger(StudentRepoJdbc.class.getName());

    /**
     * Inserts a new student record into the database.
     * The ID is auto-generated by the database and returned in the created Student.
     *
     * @return the created Student.
     */
    @Override
    public Student save(String name, String email, String phone, LocalDate dob, String address, Departments department, Status status) {
        String sql = "INSERT INTO students (name, email, phone, dob, address, department, status) VALUES (?, ?, ?, ?, ?, ?, ?)";

        try (Connection conn = DatabaseConnector.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            pstmt.setString(1, name);
            pstmt.setString(2, email);
            pstmt.setString(3, phone);
            pstmt.setDate(4, Date.valueOf(dob));
            pstmt.setString(5, address);
            pstmt.setString(6, department.name());
            pstmt.setString(7, status.name());

            int affectedRows = pstmt.executeUpdate();

            if (affectedRows > 0) {
                try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        int newId = generatedKeys.getInt(1);
                        return new Student(newId, name, email, phone, dob, address, department, status);
                    }
                }
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error saving student to database", e);
            // Throw a runtime exception to indicate a critical failure.
            throw new RuntimeException("Failed to save student due to a database error.", e);
        }

        // If we reach this point, it means the student was not saved and no ID was generated. This is an error.
        throw new RuntimeException("Failed to save student, no ID obtained.");
    }

    /**
     * Finds a student by their unique ID.
     *
     * @return an Optional containing the found Student or empty Optional if not found or on error.
     */
    @Override
    public Optional<Student> findById(int studentId) {
        String sql = "SELECT * FROM students WHERE id = ?";

        try (Connection conn = DatabaseConnector.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, studentId);

            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    return Optional.of(mapRowToStudent(rs));
                }
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error finding student by ID", e);
        }
        return Optional.empty();
    }

    @Override
    public Optional<Student> update(Student student) {
        String sql = "UPDATE students SET name = ?, email = ?, phone = ?, dob = ?, address = ?, department = ?, status = ? WHERE id = ?";

        try (Connection conn = DatabaseConnector.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setString(1, student.name());
            pstmt.setString(2, student.email());
            pstmt.setString(3, student.phone());
            pstmt.setDate(4, Date.valueOf(student.DOB()));
            pstmt.setString(5, student.address());
            pstmt.setString(6, student.department().name());
            pstmt.setString(7, student.status().name());
            pstmt.setInt(8, student.id());

            int affectedRows = pstmt.executeUpdate();

            if (affectedRows > 0) {
                return Optional.of(student);
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error updating student", e);
        }
        return Optional.empty();
    }

    @Override
    public boolean deleteById(int studentId) {
        String sql = "DELETE FROM students WHERE id = ?";

        try (Connection conn = DatabaseConnector.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, studentId);
            int affectedRows = pstmt.executeUpdate();
            return affectedRows > 0;

        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error deleting student by ID", e);
        }
        return false;
    }

    @Override
    public List<Student> findAll() {
        List<Student> students = new ArrayList<>();
        String sql = "SELECT * FROM students";

        try (Connection conn = DatabaseConnector.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {

            while (rs.next()) {
                students.add(mapRowToStudent(rs));
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error fetching all students", e);
        }
        return students;
    }

    // Helper method to convert the current ResultSet row to a Student object
    private Student mapRowToStudent(ResultSet rs) throws SQLException {
        int id = rs.getInt("id");
        String name = rs.getString("name");
        String email = rs.getString("email");
        String phone = rs.getString("phone");
        LocalDate dob = rs.getDate("dob").toLocalDate();
        String address = rs.getString("address");
        Departments department = Departments.valueOf(rs.getString("department"));
        Status status = Status.valueOf(rs.getString("status"));

        return new Student(id, name, email, phone, dob, address, department, status);
    }
}

